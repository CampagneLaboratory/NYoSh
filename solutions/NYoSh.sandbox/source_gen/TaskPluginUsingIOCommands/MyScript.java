package TaskPluginUsingIOCommands;

/*Generated by MPS */

import java.util.Set;
import java.util.HashSet;
import org.campagnelab.nyosh.exec.CommandAssembler;
import org.campagnelab.nyosh.exec.OutputConsumerToString;
import org.campagnelab.nyosh.exec.CommandExecutionPlan;
import org.campagnelab.nyosh.logging.Log4JInitializer;
import org.campagnelab.nyosh.environment.parsers.Parser;
import org.campagnelab.nyosh.environment.parsers.JVMEnvParser;
import java.util.SortedSet;
import org.campagnelab.nyosh.environment.parsers.ScriptVariable;
import org.campagnelab.nyosh.environment.parsers.GobyWebParser;
import org.campagnelab.nyosh.environment.NYoShRuntimeEnvironment;
import org.campagnelab.stepslogger.FileStepsLogger;
import java.io.File;
import java.io.IOException;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MyScript {
  private static Set<String> exportedVariables = new HashSet<String>();

  private static String fetch(String command, String slotname) {
    String files;
    {
      StringBuffer commandBuffer = new StringBuffer();
      CommandAssembler assembler = new CommandAssembler();
      assembler.appendBashFragment(command+" --fetch "+slotname);
      OutputConsumerToString consumeProcessOutputToVar = new OutputConsumerToString();
      assembler.consumeStandardOutput(consumeProcessOutputToVar);
      CommandExecutionPlan plan = null;
      lastExitCode = -1;
      try {
        assembler.setLocalEnvironment(exportedVariables);
        assembler.finishAssembly();
        plan = assembler.getCommandExecutionPlan();
        lastExitCode = plan.run();

      } finally {
        if (plan == null || !(plan.executedCompletely())) {
        } else {
        }
        files = consumeProcessOutputToVar.getValue();
      }
    }
    return files;
  }

  private static String push(String command, String slotname, String pathpattern) {
    String tags;
    {
      StringBuffer commandBuffer = new StringBuffer();
      CommandAssembler assembler = new CommandAssembler();
      assembler.appendBashFragment(command+" --push "+slotname+": "+pathpattern);
      OutputConsumerToString consumeProcessOutputToVar = new OutputConsumerToString();
      assembler.consumeStandardOutput(consumeProcessOutputToVar);
      CommandExecutionPlan plan = null;
      lastExitCode = -1;
      try {
        assembler.setLocalEnvironment(exportedVariables);
        assembler.finishAssembly();
        plan = assembler.getCommandExecutionPlan();
        lastExitCode = plan.run();

      } finally {
        if (plan == null || !(plan.executedCompletely())) {
        } else {
        }
        tags = consumeProcessOutputToVar.getValue();
      }
    }
    return tags;
  }

  private static boolean check(String command, String slotname) {
    {
      StringBuffer commandBuffer = new StringBuffer();
      CommandAssembler assembler = new CommandAssembler();
      assembler.appendBashFragment(command+" --has-fileset "+slotname);
      //  process output according to type 
      CommandExecutionPlan plan = null;
      lastExitCode = -1;
      try {
        assembler.setLocalEnvironment(exportedVariables);
        assembler.finishAssembly();
        plan = assembler.getCommandExecutionPlan();
        lastExitCode = plan.run();

      } finally {
        if (plan == null || !(plan.executedCompletely())) {
        } else {
        }
      }
    }
    return lastExitCode == 0;
  }



  public static void main(String[] arguments) {
    if (arguments.length == 0) {
      arguments = new String[]{"main"};
    }
    Log4JInitializer.init();
    // BEFORE_ENTRY_POINT_EXECUTION 

    if ("plugin_task".equals(arguments[0])) {

      if (arguments.length == 1) {
        plugin_task();
      } else {
        System.err.println("Invalid number of arguments");
      }
      finish();
      System.exit(0);
    }
    System.err.printf("The entry point %s name was not recognized", arguments[0]);
    finish();
    System.exit(1);
  }

  public static void plugin_task() {
    {
      initializeStepsLogging();
      System.out.println("Executing step: " + "Catch all step for GobyWeb");
      boolean success_t90jbv_a0g = false;
      String reason_t90jbv_a0g = "Catch all step for GobyWeb";
      Exception exception_a0g = null;
      try {
        {
          Parser parser_t90jbv_a0a0a0a5a0a0a0g = new JVMEnvParser();
          SortedSet<ScriptVariable> variables_t90jbv_a0a0a0a5a0a0a0g = parser_t90jbv_a0a0a0a5a0a0a0g.parseAtRunTime();
          Parser parser_t90jbv_b0a0a0f0a0a0a6 = new GobyWebParser();
          SortedSet<ScriptVariable> variables_t90jbv_b0a0a0f0a0a0a6 = parser_t90jbv_b0a0a0f0a0a0a6.parseAtRunTime();

          String inputFiles;
          {
            StringBuffer commandBuffer = new StringBuffer();
            CommandAssembler assembler = new CommandAssembler();
            assembler.appendBashFragment(NYoShRuntimeEnvironment.getEnvironment().getVariableValue("FILESET_COMMAND")+" --fetch "+"IMAGE");
            OutputConsumerToString consumeProcessOutputToVar = new OutputConsumerToString();
            assembler.consumeStandardOutput(consumeProcessOutputToVar);
            CommandExecutionPlan plan = null;
            lastExitCode = -1;
            try {
              assembler.setLocalEnvironment(exportedVariables);
              assembler.finishAssembly();
              plan = assembler.getCommandExecutionPlan();
              lastExitCode = plan.run();

            } finally {
              if (plan == null || !(plan.executedCompletely())) {
              } else {
              }
              inputFiles = consumeProcessOutputToVar.getValue();
            }
          }

          String registeredTags;
          String outputStats = new PathPatternMatcher().match("*.tgz").exclude().resolve();
          {
            StringBuffer commandBuffer = new StringBuffer();
            CommandAssembler assembler = new CommandAssembler();
            assembler.appendBashFragment(NYoShRuntimeEnvironment.getEnvironment().getVariableValue("FILESET_COMMAND")+" --push "+"STATS"+": "+outputStats);
            OutputConsumerToString consumeProcessOutputToVar = new OutputConsumerToString();
            assembler.consumeStandardOutput(consumeProcessOutputToVar);
            CommandExecutionPlan plan = null;
            lastExitCode = -1;
            try {
              assembler.setLocalEnvironment(exportedVariables);
              assembler.finishAssembly();
              plan = assembler.getCommandExecutionPlan();
              lastExitCode = plan.run();

            } finally {
              if (plan == null || !(plan.executedCompletely())) {
              } else {
              }
              registeredTags = consumeProcessOutputToVar.getValue();
            }
          }

        }
        success_t90jbv_a0g = true;
      } catch (Exception e) {
        exception_a0g = e;

      } finally {
        if (!(success_t90jbv_a0g)) {
        } else {
        }

        try {
          // This was the last step, we need to close the stepslogger: 
          _steps.close();

        } catch (Exception e) {
          if (LOG.isInfoEnabled()) {
            LOG.info("An error occured closing stepslogger", e);
          }
        }
      }
    }
    // end of reduce_step 
  }

  public static void finish() {
  }

  private static FileStepsLogger _steps;
// declared flag removed
  public static void initializeStepsLogging() {
    if (MyScript._steps == null) {
      MyScript._steps = new FileStepsLogger(new File("./"));
    }
  }

  public static void fail(boolean mustBeTrue, String reason) {
    fail(mustBeTrue, reason, 1);
  }

  private static void done(String stepDescription, int statusCode) {
    MyScript._steps.step(stepDescription, statusCode);
  }

  /*package*/ static void fail(boolean mustBeTrue, String reason, int statusCode) {
    if (!(mustBeTrue)) {
      MyScript._steps.error(reason);
      try {
        MyScript._steps.close();
      } catch (IOException e) {
        //  we tried to close stepslogger. Giving up now. 
      }
      System.exit(statusCode);
    }
  }

  private static int lastExitCode = 0;
  private static ErrorManagementImplementation errorManagement = new ErrorManagementImplementation();
  protected static Logger LOG = LogManager.getLogger(MyScript.class);
}
