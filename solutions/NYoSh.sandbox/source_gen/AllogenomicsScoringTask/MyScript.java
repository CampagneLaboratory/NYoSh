package AllogenomicsScoringTask;

/*Generated by MPS */

import java.util.Set;
import java.util.HashSet;
import org.campagnelab.nyosh.exec.CommandAssembler;
import org.campagnelab.nyosh.exec.OutputConsumerToString;
import org.campagnelab.nyosh.exec.CommandExecutionPlan;
import org.campagnelab.nyosh.logging.Log4JInitializer;
import org.campagnelab.nyosh.environment.parsers.Parser;
import org.campagnelab.nyosh.environment.parsers.JVMEnvParser;
import java.util.SortedSet;
import org.campagnelab.nyosh.environment.parsers.ScriptVariable;
import org.campagnelab.nyosh.environment.parsers.GobyWebParser;
import org.campagnelab.nyosh.environment.NYoShRuntimeEnvironment;
import org.campagnelab.stepslogger.FileStepsLogger;
import java.io.File;
import java.io.IOException;
import org.apache.log4j.Logger;
import org.apache.log4j.LogManager;

public class MyScript {
  private static Set<String> exportedVariables = new HashSet<String>();

  private static String fetch(String command, String slotname) {
    String files;
    {
      StringBuffer commandBuffer = new StringBuffer();
      CommandAssembler assembler = new CommandAssembler();
      assembler.appendBashFragment(command+" --fetch "+slotname);
      OutputConsumerToString consumeProcessOutputToVar = new OutputConsumerToString();
      assembler.consumeStandardOutput(consumeProcessOutputToVar);
      CommandExecutionPlan plan = null;
      lastExitCode = -1;
      try {
        assembler.setLocalEnvironment(exportedVariables);
        assembler.finishAssembly();
        plan = assembler.getCommandExecutionPlan();
        lastExitCode = plan.run();

      } finally {
        if (plan == null || !(plan.executedCompletely())) {
          errorManagement.exception("failed executing: " + commandBuffer.toString(), 0, null);
        } else {
          errorManagement.recordStepDone("successfully executed: " + commandBuffer.toString());
        }
        files = consumeProcessOutputToVar.getValue();
      }
    }
    return files;
  }

  private static String push(String command, String slotname, String pathpattern) {
    String tags;
    {
      StringBuffer commandBuffer = new StringBuffer();
      CommandAssembler assembler = new CommandAssembler();
      assembler.appendBashFragment(command+" --push "+slotname+": "+pathpattern);
      OutputConsumerToString consumeProcessOutputToVar = new OutputConsumerToString();
      assembler.consumeStandardOutput(consumeProcessOutputToVar);
      CommandExecutionPlan plan = null;
      lastExitCode = -1;
      try {
        assembler.setLocalEnvironment(exportedVariables);
        assembler.finishAssembly();
        plan = assembler.getCommandExecutionPlan();
        lastExitCode = plan.run();

      } finally {
        if (plan == null || !(plan.executedCompletely())) {
          errorManagement.exception("failed executing: " + commandBuffer.toString(), 0, null);
        } else {
          errorManagement.recordStepDone("successfully executed: " + commandBuffer.toString());
        }
        tags = consumeProcessOutputToVar.getValue();
      }
    }
    return tags;
  }

  private static boolean check(String command, String slotname) {
    {
      StringBuffer commandBuffer = new StringBuffer();
      CommandAssembler assembler = new CommandAssembler();
      assembler.appendBashFragment(command+" --has-fileset "+slotname);
      //  process output according to type 
      CommandExecutionPlan plan = null;
      lastExitCode = -1;
      try {
        assembler.setLocalEnvironment(exportedVariables);
        assembler.finishAssembly();
        plan = assembler.getCommandExecutionPlan();
        lastExitCode = plan.run();

      } finally {
        if (plan == null || !(plan.executedCompletely())) {
          errorManagement.exception("failed executing: " + commandBuffer.toString(), 0, null);
        } else {
          errorManagement.recordStepDone("successfully executed: " + commandBuffer.toString());
        }
      }
    }
    return lastExitCode == 0;
  }



  public static void main(String[] arguments) {
    if (arguments.length == 0) {
      arguments = new String[]{"main"};
    }
    Log4JInitializer.init();
    // BEFORE_ENTRY_POINT_EXECUTION 

    if ("plugin_task".equals(arguments[0])) {

      if (arguments.length == 1) {
        plugin_task();
      } else {
        System.err.println("Invalid number of arguments");
      }
      finish();
      System.exit(0);
    }
    System.err.printf("The entry point %s name was not recognized", arguments[0]);
    finish();
    System.exit(1);
  }

  public static void plugin_task() {
    {
      initializeStepsLogging();
      System.out.println("Executing step: " + "Catch all step for GobyWeb");
      boolean success_t90jbv_a0g = false;
      String reason_t90jbv_a0g = "Catch all step for GobyWeb";
      Exception exception_a0g = null;
      try {
        {
          Parser parser_t90jbv_a0a0a0a5a0a0a0g = new JVMEnvParser();
          SortedSet<ScriptVariable> variables_t90jbv_a0a0a0a5a0a0a0g = parser_t90jbv_a0a0a0a5a0a0a0g.parseAtRunTime();
          Parser parser_t90jbv_b0a0a0f0a0a0a6 = new GobyWebParser();
          SortedSet<ScriptVariable> variables_t90jbv_b0a0a0f0a0a0a6 = parser_t90jbv_b0a0a0f0a0a0a6.parseAtRunTime();

          String vcfInputFilename = fetch(NYoShRuntimeEnvironment.getEnvironment().getVariableValue("FILESET_COMMAND"), "VCF");
          String phenotypeFilename = fetch(NYoShRuntimeEnvironment.getEnvironment().getVariableValue("FILESET_COMMAND"), "PHENOTYPE");
          String memoryOptions = NYoShRuntimeEnvironment.getEnvironment().getVariableValue("PLUGIN_NEED_PROCESS_JVM");
          String jarFilename = NYoShRuntimeEnvironment.getEnvironment().getVariableValue("RESOURCES_ALLOGENOMICS_SCORING_TOOL_ALLOGENOMICS_JAR");
          //  ORG=` echo ${ORGANISM} | tr [:lower:] [:upper:]  `\n    BUILD_NUMBER=`echo ${GENOME_REFERENCE_ID} | awk -F\. '{print $1}' | tr [:lower:] [:upper:] `\n    ENSEMBL_RELEASE=`echo ${GENOME_REFERENCE_ID} | awk -F\. '{print $(NF)}'| tr [:lower:] [:upper:] `\n\n    SEQUENCE_CACHE_DIR=$(eval echo \${RESOURCES_ARTIFACTS_GOBY_INDEXED_GENOMES_SEQUENCE_CACHE_${ORG}_${BUILD_NUMBER}_${ENSEMBL_RELEASE}})\n 
          String genome = "";
          genome = NYoShRuntimeEnvironment.getEnvironment().getVariableValue(" RESOURCES_ARTIFACTS_LAST_INDEX_TOPLEVEL_IDS_HOMO_SAPIENS_1000GENOMES_37");
          String pairsFilename = phenotypeFilename;
          {
            StringBuffer commandBuffer = new StringBuffer();
            CommandAssembler assembler = new CommandAssembler();
            assembler.appendCommand(" java -Xms"+memoryOptions+" -Xmx"+memoryOptions+" -jar "+jarFilename+" -i "+vcfInputFilename+" -a protein_coding.gtf --phenotype "+pairsFilename+" --output-format TSV --only-non-synonymous-coding --clinical --vep --genome "+genome+"  -t transmembrane-transcripts.tsv -o out.tsv "+" "+" ");
            commandBuffer.append(" java -Xms"+memoryOptions+" -Xmx"+memoryOptions+" -jar "+jarFilename+" -i "+vcfInputFilename+" -a protein_coding.gtf --phenotype "+pairsFilename+" --output-format TSV --only-non-synonymous-coding --clinical --vep --genome "+genome+"  -t transmembrane-transcripts.tsv -o out.tsv "+" "+" ");
            //  process output according to type 
            CommandExecutionPlan plan = null;
            lastExitCode = -1;
            try {
              assembler.setLocalEnvironment(exportedVariables);
              assembler.finishAssembly();
              plan = assembler.getCommandExecutionPlan();
              lastExitCode = plan.run();

            } finally {
              if (plan == null || !(plan.executedCompletely())) {
                errorManagement.exception("failed executing: " + commandBuffer.toString(), 0, null);
              } else {
                errorManagement.recordStepDone("successfully executed: " + commandBuffer.toString());
              }
            }
          }
          String tag = push(NYoShRuntimeEnvironment.getEnvironment().getVariableValue("FILESET_COMMAND"), "Allogenomic Scores", " out.tsv");
          System.out.println("tag=" + tag);
        }
        success_t90jbv_a0g = true;
      } catch (Exception e) {
        exception_a0g = e;

      } finally {
        if (!(success_t90jbv_a0g)) {
          errorManagement.exception("step " + reason_t90jbv_a0g + " failed.", 0, exception_a0g);
        } else {
          errorManagement.recordStepDone(reason_t90jbv_a0g);
        }

        try {
          // This was the last step, we need to close the stepslogger: 
          _steps.close();

        } catch (Exception e) {
          if (LOG.isInfoEnabled()) {
            LOG.info("An error occured closing stepslogger", e);
          }
        }
      }
    }
    // end of reduce_step 








  }

  public static void finish() {
  }

  private static FileStepsLogger _steps;
// declared flag removed
  public static void initializeStepsLogging() {
    if (MyScript._steps == null) {
      MyScript._steps = new FileStepsLogger(new File("./"));
    }
  }

  public static void fail(boolean mustBeTrue, String reason) {
    fail(mustBeTrue, reason, 1);
  }

  private static void done(String stepDescription, int statusCode) {
    MyScript._steps.step(stepDescription, statusCode);
  }

  /*package*/ static void fail(boolean mustBeTrue, String reason, int statusCode) {
    if (!(mustBeTrue)) {
      MyScript._steps.error(reason);
      try {
        MyScript._steps.close();
      } catch (IOException e) {
        //  we tried to close stepslogger. Giving up now. 
      }
      System.exit(statusCode);
    }
  }

  private static int lastExitCode = 0;
  private static ErrorManagementImplementation errorManagement = new ErrorManagementImplementation();
  protected static Logger LOG = LogManager.getLogger(MyScript.class);
}
